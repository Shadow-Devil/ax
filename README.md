# [ax](https://ax.010.one)
This is a minimal x86-64 emulator for WebAssembly. It executes real machine code and can be used to emulate x86-64 user-space programs in the browser.

Note that not all implemented instructions work exactly the same way as on real hardware, but the goal is to be as close as possible while staying reasonable. Currently only around 50 instruction mnemonics are implemented (some opcodes are omitted, but the most important stuff is there).

Additionally, this repository contains scripts that should be interesting for anyone who wants to write an x86-64 emulator. The most important one, [`t.py`](t.py), automatically generates test cases for an instruction by trying out different inputs and thus finding many flag combinations. See [automatically generate test cases](#automatically-generate-test-cases) for more information.

## Try it out!
You can try out the emulator right now by visiting [the website](https://ax.010.one), selecting a suitable ELF binary and clicking "Run". The emulator will then execute the binary and show the output. Note that currently support for ELF binaries is limited/buggy (there are some problems getting libc to work), you can however use binaries from the [`examples/programs`](examples/programs) directory. The source code for this site is in the [`examples/web`](examples/web) directory.

Other than that, you can also find it in use on the [MemeAssembly Playground](https://memeasm.010.one). MemeAssembly is a meme programming language that compiles to x86-64 instructions, which are executed by this emulator. The site also emulates some syscalls like `read`, `write` and `exit` to make the programs work.

## Development setup
1. Make sure you have installed Rust/Cargo, Node.js, NPM, Python, PIP, Make, GCC and the GNU Assembler
2. [Install `wasm-pack`](https://rustwasm.github.io/wasm-pack/installer/)
3. You should now be able to build the WebAssembly module with `make`
4. You can run `make dependencies` to install `cargo-watch`, `cargo-tarpaulin` (for generating test coverage info files) and python script dependencies
5. Try out running `cargo test` or `make watch-tests` to run tests
6. Now switch to the `examples/web` directory and install web dependencies with `npm install`
7. Run `make watch` in one terminal to rebuild the WebAssembly module on changes, then run `make web` in another terminal to start the development server
8. Open the local example site and make changes! (link should be in the `make web` output)

### Generate mnemonic stubs
The [`generate.py`](generate.py) script is used for generating instruction implementation stubs. You can e.g. run `python3 generate.py push` to generate a file for all instruction mnemonics that start with `push`; if you only want more exact matches use `push_` as argument. Note that you must have run a build for the WebAssembly package, as otherwise the script won't be able to find the files from the [`iced-x86` crate](https://crates.io/crates/iced-x86) that are used for generating the stubs.

Afterwards, run `make switch` to regenerate the instruction mnemonic switch statement (in [`src/instructions/generated.rs`](src/instructions/generated.rs)). Now your new stub functions are reachable.

### Automatically generate test cases
The repository comes with scripts for generating test cases for x86-64 instructions. The test cases are generated by running e.g. `python3 t.py add al, [rbx]`, which tries around 6000 different inputs for the instruction (the extreme mode with `-e` tries around 100k inputs).
The generated test cases are deduplicated, resulting in only one test case per unique combination of flags that are set and cleared. Note that not necessarily all combinations will be discovered.

Here is one of 19 test cases that was automatically discovered for `add al, [rbx]` (without `-e`):
```rust
// ax_test is macro that sets up the emulator, then runs setup and a post-execution assertion function
// add al, byte ptr [rbx]
ax_test![add_al_byte_ptr_rbx_cf;
    // The encoded instruction bytes:
    0x2, 0x3;
    // A setup function that is called before the instruction is executed:
    |a: &mut Axecutor| {
        write_reg_value!(b; a; AL; 0x20);

        // This sets up a memory area with a size of one byte, containing 0xff
        write_reg_value!(q; a; RBX; 0x1000);
        a.mem_init_zero(0x1000, 1).unwrap();
        a.mem_write_8(0x1000, 0xff).unwrap();
    };
    // This function is called after the instruction ran and checks the result:
    |a: Axecutor| {
        assert_reg_value!(b; a; AL; 0x1f);
        // Also make sure the source operand is unchanged
        assert_eq!(a.mem_read_8(0x1000).unwrap(), 0xff);
    };
    // On the left side of `;` are the flags that must be set after the instruction ran,
    // on the right are flags that must not be set
    (FLAG_CF; FLAG_PF | FLAG_ZF | FLAG_SF | FLAG_OF)
];
```

The test case generation script [`t.py`](t.py) currently only supports register, a subset of memory and immediate operands. It requires that the GNU Assembler `as` and `gcc` are installed and must be run on x86-64 Linux. It places thousands of generated assembly files and binaries in `/dev/shm/ax_*`, so in case you run out of RAM that is the place to check.

If you want to adjust `t.py` for testing your own emulator, you should adjust the `__str__` method of the `TestCase` class to generate different syntax with the same information.

Another script for testing jumps ([`j.py`](j.py)) is also available, but it's not as automated. Some other convenience copy-paste texts can be generated with [`a.py`](a.py), e.g. with `python3 a.py add al, [rbx]` and then selecting `u` you'll get a code snippet for a JavaScript `Uint8Array` containing the bytes of the instruction.

### Links
* [Intel x64 Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
* [AMD64 Developer Guides](https://developer.amd.com/resources/developer-guides-manuals/)


### Limitations
* Only the Signed, Carry, Overflow, Zero and Parity status flags are supported
* Most instructions aren't implemented, especially
  * Anything with SSE registers
  * Anything I found too legacy
  * Many instructions
  * No support for anything related to segments
* Syscall and Interrupts are not implemented to spec. If you have registered hooks (using `hook_before_mnemonic` or `hook_after_mnemonic`) they are essentially a no-op with your handler executing, otherwise an error is returned/exception is thrown
* The memory implementation is quite weird and needs an overhaul


### Ideas
* Look into parsing ELF files directly using something like https://crates.io/crates/object
* TODO: check startup memory layout (especially everything above initial RSP where argc etc. are stored)
