mod functions;
mod instructions;

use instructions::{axecutor::Axecutor, errors::AxError};
use js_sys::Uint8Array;
use wasm_bindgen::prelude::*;

impl From<AxError> for JsValue {
    fn from(e: AxError) -> Self {
        JsValue::from_str(&e.to_string())
    }
}

#[wasm_bindgen]
pub async fn execute_sync_or_async(arr: Uint8Array, rip: u64) -> Result<JsValue, JsValue> {
    // TODO: Figure out a good API to interact with syscalls (or any instruction?)
    // Might actually make sense to just expose all (implemented) instructions, maybe also generated by make switch
    // That way a simple hashmap lookup can be used to call the right function. Maybe also add a "before instruction" and "after instruction" type of hook
    // Maybe store both before and after functions next to each other so only one lookup is needed per instruction
    // Also use normal rust callbacks and convert the javascript versions in this file (or accept both?), everything else would be quite ugly
    let _ax = Axecutor::new(&arr.to_vec(), rip, rip);

    Ok(JsValue::NULL)
    // functions::run_any_function(function_or_promise, vec![JsValue::from("a")]).await
}
