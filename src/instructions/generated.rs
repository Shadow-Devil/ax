// THIS FILE IS AUTOGENERATED, DO NOT EDIT
// You can regenerate it using `make generate` after creating a new instruction file with `python3 generate.py <mneumonic>`

use super::{axecutor::Axecutor, errors::AxError};
use iced_x86::{
    Instruction,
    Mnemonic::{self, *},
};
use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::wasm_bindgen;

impl Axecutor {
    pub fn switch_instruction_mnemonic(&mut self, i: Instruction) -> Result<(), AxError> {
        match i.mnemonic() {
            Add => self.mnemonic_add(i),
            Call => self.mnemonic_call(i),
            Cmp => self.mnemonic_cmp(i),
            Dec => self.mnemonic_dec(i),
            Inc => self.mnemonic_inc(i),
            Ja => self.mnemonic_ja(i),
            Jae => self.mnemonic_jae(i),
            Jb => self.mnemonic_jb(i),
            Jbe => self.mnemonic_jbe(i),
            Je => self.mnemonic_je(i),
            Jecxz => self.mnemonic_jecxz(i),
            Jg => self.mnemonic_jg(i),
            Jge => self.mnemonic_jge(i),
            Jl => self.mnemonic_jl(i),
            Jle => self.mnemonic_jle(i),
            Jmp => self.mnemonic_jmp(i),
            Jne => self.mnemonic_jne(i),
            Jno => self.mnemonic_jno(i),
            Jnp => self.mnemonic_jnp(i),
            Jns => self.mnemonic_jns(i),
            Jo => self.mnemonic_jo(i),
            Jp => self.mnemonic_jp(i),
            Jrcxz => self.mnemonic_jrcxz(i),
            Js => self.mnemonic_js(i),
            Lea => self.mnemonic_lea(i),
            Mov => self.mnemonic_mov(i),
            Nop => self.mnemonic_nop(i),
            Not => self.mnemonic_not(i),
            Pop => self.mnemonic_pop(i),
            Push => self.mnemonic_push(i),
            Ret => self.mnemonic_ret(i),
            Shl => self.mnemonic_shl(i),
            Sub => self.mnemonic_sub(i),
            Test => self.mnemonic_test(i),
            Xor => self.mnemonic_xor(i),
            _ => Err(AxError::from(format!(
                "unimplemented mnemonic {:?}",
                i.mnemonic()
            ))),
        }
    }
}

#[wasm_bindgen(js_name = Mnemonic)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum SupportedMnemonic {
    Add = 7,
    Call = 59,
    Cmp = 93,
    Dec = 137,
    Inc = 279,
    Ja = 297,
    Jae = 298,
    Jb = 299,
    Jbe = 300,
    Je = 302,
    Jecxz = 303,
    Jg = 304,
    Jge = 305,
    Jl = 306,
    Jle = 307,
    Jmp = 308,
    Jne = 310,
    Jno = 311,
    Jnp = 312,
    Jns = 313,
    Jo = 314,
    Jp = 315,
    Jrcxz = 316,
    Js = 317,
    Lea = 374,
    Mov = 414,
    Nop = 465,
    Not = 466,
    Pop = 590,
    Push = 640,
    Ret = 662,
    Shl = 712,
    Sub = 740,
    Test = 751,
    Xor = 1518,
}

impl SupportedMnemonic {
    pub fn name(&self) -> String {
        format!("{:?}", self)
    }
}

impl From<Mnemonic> for SupportedMnemonic {
    fn from(mnemonic: Mnemonic) -> Self {
        match mnemonic {
            Add => SupportedMnemonic::Add,
            Call => SupportedMnemonic::Call,
            Cmp => SupportedMnemonic::Cmp,
            Dec => SupportedMnemonic::Dec,
            Inc => SupportedMnemonic::Inc,
            Ja => SupportedMnemonic::Ja,
            Jae => SupportedMnemonic::Jae,
            Jb => SupportedMnemonic::Jb,
            Jbe => SupportedMnemonic::Jbe,
            Je => SupportedMnemonic::Je,
            Jecxz => SupportedMnemonic::Jecxz,
            Jg => SupportedMnemonic::Jg,
            Jge => SupportedMnemonic::Jge,
            Jl => SupportedMnemonic::Jl,
            Jle => SupportedMnemonic::Jle,
            Jmp => SupportedMnemonic::Jmp,
            Jne => SupportedMnemonic::Jne,
            Jno => SupportedMnemonic::Jno,
            Jnp => SupportedMnemonic::Jnp,
            Jns => SupportedMnemonic::Jns,
            Jo => SupportedMnemonic::Jo,
            Jp => SupportedMnemonic::Jp,
            Jrcxz => SupportedMnemonic::Jrcxz,
            Js => SupportedMnemonic::Js,
            Lea => SupportedMnemonic::Lea,
            Mov => SupportedMnemonic::Mov,
            Nop => SupportedMnemonic::Nop,
            Not => SupportedMnemonic::Not,
            Pop => SupportedMnemonic::Pop,
            Push => SupportedMnemonic::Push,
            Ret => SupportedMnemonic::Ret,
            Shl => SupportedMnemonic::Shl,
            Sub => SupportedMnemonic::Sub,
            Test => SupportedMnemonic::Test,
            Xor => SupportedMnemonic::Xor,
            _ => panic!("unimplemented mnemonic {:?}", mnemonic),
        }
    }
}
